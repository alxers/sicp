;; 1.1.3 Evaluating combinations
;; 
;; To evaluate a combination:
;; 1. Evaluate the subexpressions of the combination
;; 2. Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpression (the operands).

(define (square x)
  (* x x))

(define (sq-sum x y)
  (+ (square x) (square y)))

;; If we call (sq-sum (+ a 1) (* a 2)) where a is 5 then:

;; "applicative order"

;; 1. (sq-sum (+ 5 1) (* 5 2)) replace parameter a by the argument 5
;; 2. (+ (square 6) (square 10)) evaluate operands and replace sq-sum with the body of the procedure sq-sum
;; 3. (+ (* 6 6) (* 10 10)) replace square with the body of the procedure square
;; 4. (+ 36 100)
;; 5. 136
;; 
;; According to the description of evaluation given in section 1.1.3, the interpreter first evaluates the
;; operator and operands and then applies the resulting procedure to the resulting arguments.
;; An alternative evaluation model would not evaluate the operands
;; until their values were needed. Instead it would first substitute operand expressions for parameters
;; until it obtained an expression involving only primitive operators, and would then perform the
;; evaluation.
;; 
;; "normal-order"

1. (sq-sum (+ 5 1) (* 5 2))
2. (+ (square (+ 5 1) square (* 5 2)))
3. (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))

;; And then reduction
;; 
;; 4. (+ (* 6 6) (* 10 10))
;; 5. (+ 36 100)
;; 6. 136

;; This alternative "fully expand and then reduce" evaluation method is known as normal-order 
;; evaluation.

;; In contrast to the "evaluate the arguments and then apply" method that the interpreter
;; actually uses, which is called applicative-order evaluation

;; Ex. 1.3

(define (square x)
    (* x x))

(define (sum-of-squares a b)
    (+ (square a) (square b)))


(define (sum-of-two-largest a b c)
    (cond ((and (< c a) (< c b)) (sum-of-squares a b))
          ((and (< a c) (< a b)) (sum-of-squares c b))
          ((and (< b c) (< b a)) (sum-of-squares a c))
          ((= a b) (sum-of-squares a c))
          ((= a c) (sum-of-squares a b))
          ((= b c) (sum-of-squares a c))
          ((= a b c) (sum-of-squares a b))
          (else "really?")
          )
    )

;; Alternative and more clear solution

(define (sq-sum-of-lg x y z)
  (if (> x y)
    (sum-of-squares y (if (> x z) x z))
    (sum-of-squares x (if (> y z) y z))))


;; Ex. 1.5

(define (p) (p))

(define (test x y)
    (if (= x 0)
        0
        y))

(test 0 (p))

;; In case of an applicative order we won't be able to evaluate operands because of recursive procedure "p"
;; With normal order first if will be evaluated

;; Ex. 1.7

(define (square x)
    (* x x))

(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)
        )
       )
      
(define (improve guess x)
    (average (/ x guess) guess)
    )

(define (average x y)
    (/ (+ x y) 2)
    )

(define (good-enough? guess x)
    (< (abs (- x (square guess))) 0.001)
    )

(define (sqrt x)
    (sqrt-iter 1.0 x))


(define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause))
    )


;; It'll be an infinite loop with new-if.
;; if is a special form, so it evaluates then-clause first
;; new-if is a procedure, it tries to evaluate all the arguments (and because of an applicative order it gets stuck in an infinite loop)

;; It will work if we put cond like this
(define (sqrt-iter1 guess x)
    (cond ((good-enough? guess x) guess)
        (else (sqrt-iter (improve guess x) x))
        )
       )

;; Ex. 1.8

(define (cqrt-iter guess x)
    (if (cqrt-good-enough? guess x)
        guess
        (cqrt-iter (cqrt-improve guess x) x)
        )
       )
      
(define (cqrt-good-enough? guess x)
    (< (abs (- x (* guess guess guess))) 0.001)
    )
      
(define (cqrt-improve guess x)
    (cqrt-average (/ x (square guess)) (* 2 guess))
    )

(define (cqrt-average x y)
    (/ (+ x y) 3)
    )
   
(define (cqrt x)
    (cqrt-iter 1.0 x))